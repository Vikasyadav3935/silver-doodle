generator client {
  provider      = "prisma-client-js"
  enableTracing = "false"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                                          String               @id @default(uuid())
  phoneNumber                                 String               @unique
  email                                       String?              @unique
  isVerified                                  Boolean              @default(false)
  createdAt                                   DateTime             @default(now())
  updatedAt                                   DateTime             @updatedAt
  audit_logs_audit_logs_target_user_idTousers audit_logs[]         @relation("audit_logs_target_user_idTousers")
  audit_logs_audit_logs_user_idTousers        audit_logs[]         @relation("audit_logs_user_idTousers")
  blacklisted_tokens                          blacklisted_tokens[]
  receivedBlocks                              Block[]              @relation("BlockReceiver")
  sentBlocks                                  Block[]              @relation("BlockSender")
  boosts                                      Boost[]
  conversations1                              Conversation[]       @relation("ConversationUser1")
  conversations2                              Conversation[]       @relation("ConversationUser2")
  receivedLikes                               Like[]               @relation("LikeReceiver")
  sentLikes                                   Like[]               @relation("LikeSender")
  matches                                     Match[]              @relation("MatchUser1")
  matchedWith                                 Match[]              @relation("MatchUser2")
  receivedMessages                            Message[]            @relation("MessageReceiver")
  sentMessages                                Message[]            @relation("MessageSender")
  notifications                               Notification[]
  otpCodes                                    OtpCode[]
  receivedPasses                              Pass[]               @relation("PassReceiver")
  sentPasses                                  Pass[]               @relation("PassSender")
  payments                                    Payment[]
  profile                                     Profile?
  pushTokens                                  PushToken[]
  receivedReports                             Report[]             @relation("ReportReceiver")
  sentReports                                 Report[]             @relation("ReportSender")
  subscription                                Subscription?
  superLikes                                  SuperLike[]
  activities                                  UserActivity[]
  user_roles_user_roles_granted_byTousers     user_roles[]         @relation("user_roles_granted_byTousers")
  user_roles_user_roles_user_idTousers        user_roles[]         @relation("user_roles_user_idTousers")
  settings                                    UserSettings?
  compatibilityScores1                        CompatibilityScore[] @relation("CompatibilityUser1")
  compatibilityScores2                        CompatibilityScore[] @relation("CompatibilityUser2")

  @@map("users")
}

model Profile {
  id                        String               @id @default(uuid())
  userId                    String               @unique
  firstName                 String
  lastName                  String?
  dateOfBirth               DateTime?
  gender                    Gender?
  bio                       String?
  occupation                String?
  company                   String?
  education                 String?
  height                    Int?
  latitude                  Float?
  longitude                 Float?
  city                      String?
  state                     String?
  country                   String?
  isVerified                Boolean              @default(false)
  isDiscoverable            Boolean              @default(true)
  showOnlineStatus          Boolean              @default(false)
  profileCompleteness       Int                  @default(0)
  extroversion              Decimal?             @db.Decimal(3, 2)
  openness                  Decimal?             @db.Decimal(3, 2)
  conscientiousness         Decimal?             @db.Decimal(3, 2)
  agreeableness             Decimal?             @db.Decimal(3, 2)
  emotional_stability       Decimal?             @db.Decimal(3, 2)
  growth_mindset            Decimal?             @db.Decimal(3, 2)
  collectivism              Decimal?             @db.Decimal(3, 2)
  spiritual_inclination     Decimal?             @db.Decimal(3, 2)
  veganism_support          Decimal?             @db.Decimal(3, 2)
  environmental_consciousness Decimal?           @db.Decimal(3, 2)
  health_focus              Decimal?             @db.Decimal(3, 2)
  social_justice            Decimal?             @db.Decimal(3, 2)
  personality_quiz_completed Boolean             @default(false)
  personality_quiz_completed_at DateTime?
  createdAt                 DateTime             @default(now())
  updatedAt                 DateTime             @updatedAt
  preferences               MatchPreference?
  photos                    Photo[]
  user                      User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  answers                   QuestionAnswer[]
  personalityAnswers        PersonalityAnswer[]
  interests                 Interest[]           @relation("InterestToProfile")

  @@map("profiles")
}

model Photo {
  id        String   @id @default(uuid())
  profileId String
  url       String
  publicId  String
  isPrimary Boolean  @default(false)
  order     Int      @default(0)
  createdAt DateTime @default(now())
  profile   Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@map("photos")
}

model Interest {
  id        String    @id @default(uuid())
  name      String    @unique
  category  String?
  createdAt DateTime  @default(now())
  profiles  Profile[] @relation("InterestToProfile")

  @@map("interests")
}

model MatchPreference {
  id               String           @id @default(uuid())
  profileId        String           @unique
  minAge           Int              @default(18)
  maxAge           Int              @default(100)
  maxDistance      Int              @default(100)
  genderPreference GenderPreference @default(ALL)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  profile          Profile          @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@map("match_preferences")
}

model Question {
  id         String           @id @default(uuid())
  text       String
  category   String?
  options    Json?
  type       QuestionType     @default(TEXT)
  isRequired Boolean          @default(false)
  order      Int
  createdAt  DateTime         @default(now())
  answers    QuestionAnswer[]

  @@map("questions")
}

model QuestionAnswer {
  id         String   @id @default(uuid())
  profileId  String
  questionId String
  answer     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  profile    Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id])

  @@unique([profileId, questionId])
  @@map("question_answers")
}

model OtpCode {
  id        String     @id @default(uuid())
  userId    String
  code      String
  purpose   OtpPurpose
  expiresAt DateTime
  isUsed    Boolean    @default(false)
  createdAt DateTime   @default(now())
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("otp_codes")
}

model Like {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String
  createdAt  DateTime @default(now())
  receiver   User     @relation("LikeReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User     @relation("LikeSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@map("likes")
}

model SuperLike {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String
  createdAt  DateTime @default(now())
  sender     User     @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@map("super_likes")
}

model Pass {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String
  createdAt  DateTime @default(now())
  receiver   User     @relation("PassReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User     @relation("PassSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@map("passes")
}

model Match {
  id           String        @id @default(uuid())
  user1Id      String
  user2Id      String
  createdAt    DateTime      @default(now())
  conversation Conversation?
  user1        User          @relation("MatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2        User          @relation("MatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@map("matches")
}

model Conversation {
  id            String    @id @default(uuid())
  matchId       String?   @unique
  user1Id       String
  user2Id       String
  lastMessageAt DateTime?
  user1LastRead DateTime?
  user2LastRead DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  match         Match?    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user1         User      @relation("ConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2         User      @relation("ConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages      Message[]

  @@map("conversations")
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  senderId       String
  receiverId     String
  content        String?
  messageType    MessageType  @default(TEXT)
  mediaUrl       String?
  mediaType      String?
  isRead         Boolean      @default(false)
  readAt         DateTime?
  editedAt       DateTime?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  receiver       User         @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Block {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String
  reason     String?
  createdAt  DateTime @default(now())
  receiver   User     @relation("BlockReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User     @relation("BlockSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@map("blocks")
}

model Report {
  id          String       @id @default(uuid())
  senderId    String
  receiverId  String
  reason      ReportReason
  description String?
  status      ReportStatus @default(PENDING)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  receiver    User         @relation("ReportReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender      User         @relation("ReportSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("reports")
}

model Subscription {
  id                   String             @id @default(uuid())
  userId               String             @unique
  plan                 SubscriptionPlan
  status               SubscriptionStatus @default(ACTIVE)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  startDate            DateTime
  endDate              DateTime
  canceledAt           DateTime?
  features             Json
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Payment {
  id                    String         @id @default(uuid())
  userId                String
  amount                Float
  currency              String         @default("USD")
  purpose               PaymentPurpose
  stripePaymentIntentId String?
  status                PaymentStatus  @default(PENDING)
  metadata              Json?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  user                  User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
}

model Boost {
  id        String    @id @default(uuid())
  userId    String
  type      BoostType
  duration  Int
  startedAt DateTime
  endsAt    DateTime
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("boosts")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model PushToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  platform  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("push_tokens")
}

model UserSettings {
  id                     String   @id @default(uuid())
  userId                 String   @unique
  emailNotifications     Boolean  @default(true)
  pushNotifications      Boolean  @default(true)
  newMatchNotifications  Boolean  @default(true)
  messageNotifications   Boolean  @default(true)
  likeNotifications      Boolean  @default(true)
  superLikeNotifications Boolean  @default(true)
  showAge                Boolean  @default(true)
  showDistance           Boolean  @default(true)
  showOnlineStatus       Boolean  @default(false)
  hideFromContacts       Boolean  @default(false)
  discoveryEnabled       Boolean  @default(true)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  user                   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model UserActivity {
  id        String       @id @default(uuid())
  userId    String
  type      ActivityType
  data      Json?
  createdAt DateTime     @default(now())
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_activities")
}

model audit_logs {
  id                                     String   @id @default(dbgenerated("gen_random_uuid()"))
  event_type                             String
  user_id                                String?
  target_user_id                         String?
  resource_type                          String?
  resource_id                            String?
  details                                Json?    @default("{}")
  metadata                               Json?    @default("{}")
  timestamp                              DateTime @default(now())
  severity                               String   @default("LOW")
  created_at                             DateTime @default(now())
  users_audit_logs_target_user_idTousers User?    @relation("audit_logs_target_user_idTousers", fields: [target_user_id], references: [id])
  users_audit_logs_user_idTousers        User?    @relation("audit_logs_user_idTousers", fields: [user_id], references: [id])

  @@index([event_type])
  @@index([severity])
  @@index([timestamp])
  @@index([user_id])
}

model blacklisted_tokens {
  id         String   @id @default(dbgenerated("gen_random_uuid()"))
  token_hash String   @unique
  user_id    String?
  expires_at DateTime
  reason     String?
  created_at DateTime @default(now())
  users      User?    @relation(fields: [user_id], references: [id])

  @@index([expires_at])
  @@index([user_id])
}

model user_roles {
  id                                 String    @id @default(dbgenerated("gen_random_uuid()"))
  user_id                            String
  role                               String    @default("USER")
  granted_by                         String?
  granted_at                         DateTime  @default(now())
  is_active                          Boolean   @default(true)
  expires_at                         DateTime?
  created_at                         DateTime  @default(now())
  updated_at                         DateTime  @default(now())
  users_user_roles_granted_byTousers User?     @relation("user_roles_granted_byTousers", fields: [granted_by], references: [id])
  users_user_roles_user_idTousers    User      @relation("user_roles_user_idTousers", fields: [user_id], references: [id], onDelete: Cascade)

  @@index([role])
  @@index([user_id])
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
}

enum GenderPreference {
  MALE
  FEMALE
  ALL
}

enum QuestionType {
  TEXT
  MULTIPLE_CHOICE
  SINGLE_CHOICE
  SCALE
  BOOLEAN
}

enum OtpPurpose {
  PHONE_VERIFICATION
  PASSWORD_RESET
  EMAIL_VERIFICATION
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  LOCATION
  GIF
}

enum ReportReason {
  INAPPROPRIATE_BEHAVIOR
  FAKE_PROFILE
  HARASSMENT
  SPAM
  UNDERAGE
  OTHER
}

enum ReportStatus {
  PENDING
  INVESTIGATING
  RESOLVED
  DISMISSED
}

enum SubscriptionPlan {
  FREE
  PREMIUM
  GOLD
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PAUSED
}

enum PaymentPurpose {
  SUBSCRIPTION
  BOOST
  SUPER_LIKES
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum BoostType {
  PROFILE_BOOST
  LOCATION_BOOST
}

enum NotificationType {
  NEW_MATCH
  NEW_MESSAGE
  NEW_LIKE
  SUPER_LIKE
  PROFILE_VIEW
  SYSTEM
}

enum ActivityType {
  LOGIN
  LOGOUT
  PROFILE_UPDATE
  PHOTO_UPLOAD
  MATCH_CREATED
  MESSAGE_SENT
  LIKE_SENT
  SUPER_LIKE_SENT
  BLOCK_USER
  REPORT_USER
  PROFILE_VIEW
  NEW_CONVERSATION
}

model PersonalityQuestion {
  id              String              @id @default(uuid())
  questionNumber  Int                 @map("question_number")
  category        String
  questionText    String              @map("question_text")
  options         Json
  scoringWeights  Json                @map("scoring_weights")
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")
  answers         PersonalityAnswer[]

  @@map("personality_questions")
}

model PersonalityAnswer {
  id             String             @id @default(uuid())
  profileId      String             @map("profile_id")
  questionId     String             @map("question_id")
  selectedOption String             @map("selected_option")
  optionIndex    Int                @map("option_index")
  createdAt      DateTime           @default(now()) @map("created_at")
  updatedAt      DateTime           @updatedAt @map("updated_at")
  profile        Profile            @relation(fields: [profileId], references: [id], onDelete: Cascade)
  question       PersonalityQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([profileId, questionId])
  @@map("personality_answers")
}

model CompatibilityScore {
  id               String   @id @default(uuid())
  user1Id          String   @map("user1_id")
  user2Id          String   @map("user2_id")
  overallScore     Decimal  @map("overall_score") @db.Decimal(5, 2)
  personalityScore Decimal  @map("personality_score") @db.Decimal(5, 2)
  lifestyleScore   Decimal  @map("lifestyle_score") @db.Decimal(5, 2)
  traitScores      Json     @map("trait_scores")
  calculatedAt     DateTime @default(now()) @map("calculated_at")
  expiresAt        DateTime @map("expires_at")
  user1            User     @relation("CompatibilityUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2            User     @relation("CompatibilityUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@map("compatibility_scores")
}
